<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEXORA25 Futuristic Tech Expo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Orbitron:700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>
    <style>
        :root {
            --primary-color: #0d1a26;
            --secondary-color: #0f2334;
            --accent-color: #ff0077;
            --text-light: #e0e0e0;
            --text-dark: #888;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--primary-color);
            color: var(--text-light);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        header {
            width: 100%;
            height: 600px; /* Set a specific height for the header to contain the effect */
            background-color: black;
            position: relative;
            overflow: hidden;
        }

        .header-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Allows mouse events to pass through to the effect */
        }

        .expo-title {
            font-size: 3em;
            text-transform: uppercase;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 0, 119, 0.5);
            margin-bottom: 10px;
        }

        .college {
            font-size: 1.2em;
            color: var(--text-dark);
            line-height: 1.4;
        }

        .distortion-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        section {
            width: 100%;
            max-width: 900px;
            padding: 40px 20px;
            box-sizing: border-box;
            border-bottom: 1px solid var(--text-dark);
        }

        .alt-bg {
            background-color: var(--secondary-color);
        }

        .light-bg {
            background-color: var(--primary-color);
        }

        h2 {
            font-size: 2em;
            color: var(--accent-color);
            margin-bottom: 20px;
        }

        .events li, .timeline li, footer p {
            list-style: none;
            text-align: left;
            margin-bottom: 15px;
            padding: 15px;
            background-color: var(--primary-color);
            border-left: 3px solid var(--accent-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .events li:hover, .timeline li:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(255, 0, 119, 0.2);
        }

        .events, .timeline {
            padding: 0;
            max-width: 700px;
            margin: auto;
        }

        .register-btn {
            background-color: var(--accent-color);
            color: var(--primary-color);
            font-size: 1.5em;
            padding: 15px 30px;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 119, 0.5);
            transition: background-color 0.3s ease, transform 0.3s ease;
        }

        .register-btn:hover {
            background-color: #ff4d99;
            transform: scale(1.05);
        }

        footer {
            width: 100%;
            padding: 20px;
            background-color: var(--secondary-color);
            color: var(--text-dark);
            font-size: 0.9em;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <header>
        <div id="grid-distortion-container" class="distortion-container"></div>
        <div class="header-content">
            <div class="expo-title">üöÄ NEXORA25 Futuristic Tech Expo</div>
            <div class="college">
                A National Level Technical Symposium<br>
                Organized by Adhiyamaan College of Engineering, Hosur<br>
                14th October 2025, 9:00 AM onwards
            </div>
        </div>
    </header>
    
    <section class="alt-bg">
        <h2>‚ÑπÔ∏è About the Tech Expo</h2>
        <p>
        NEXORA25 brings future technology to the present‚Äîan immersive technical symposium for visionaries, innovators, and tech enthusiasts. Experience hands-on competitions, networking, and the spirit of engineering excellence backed by ISTE and Adhiyamaan College of Engineering.
        </p>
    </section>

    <section class="light-bg">
        <h2>üèÜ Main Events & Competitions</h2>
        <ul class="events">
            <li><strong>PIXEL PITCH (Poster Making)</strong><br>Team up to 3 members. Topic: Cyber Security Awareness. 1-page poster, present in 5 minutes. Submission by Oct 10, 2025.</li>
            <li><strong>QUIZTEONICS (Tech Quiz)</strong><br>Individual event. 2 rounds, 45 questions. Rapid-fire finals.</li>
            <li><strong>QUANTUMFIX (Debugging)</strong><br>Individual event. Code or circuit debugging. Complete within 30 minutes.</li>
            <li><strong>FUTURE FRAME (Paper Presentation)</strong><br>Up to 3 members/team. Abstract & PPT submission: Oct 6 & 10. Presentation: 6 minutes + Q&A.</li>
        </ul>
    </section>

    <section class="alt-bg">
        <h2>üìÖ Registration & Important Dates</h2>
        <ul class="timeline">
            <li><strong>Registration Fee:</strong> ‚Çπ200 per person</li>
            <li><strong>Registration Closes:</strong> 6th October 2025</li>
            <li><strong>Abstract Submission:</strong> 6th October 2025</li>
            <li><strong>PPT / Poster Submission:</strong> 10th October 2025</li>
            <li><strong>Event Day:</strong> 14th October 2025, 9:00 AM</li>
        </ul>
        <button class="register-btn" onclick="window.location.href='https://forms.gle/DEVuQQqnBmK8Cc5d8'">Register Now</button>
    </section>

    <section class="light-bg">
        <h2>üìû Contact & Support</h2>
        <ul>
            <li>Email: iste.studentchapter15@gmail.com</li>
            <li>Phone: 63853 58009 | 93450 53723</li>
            <li>Faculty Advisor: Prof. M. Sukanya (ISTE Students Chapter, ACE, Hosur)</li>
        </ul>
    </section>

    <footer>
        ¬© 2025 NEXORA25 Tech Expo ‚Ä¢ Adhiyamaan College of Engineering ‚Ä¢ Designed by the ISTE Students Chapter
    </footer>

    <script>
        const vertexShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;

            void main() {
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uDataTexture;
            uniform sampler2D uTexture;
            uniform vec4 resolution;
            varying vec2 vUv;

            void main() {
                vec2 uv = vUv;
                vec4 offset = texture2D(uDataTexture, vUv);
                gl_FragColor = texture2D(uTexture, uv - 0.02 * offset.rg);
            }
        `;

        const initGridDistortion = ({ grid = 15, mouse = 0.1, strength = 0.15, relaxation = 0.9, imageSrc, containerId }) => {
            const container = document.getElementById(containerId);
            if (!container) return;

            const scene = new THREE.Scene();
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            const camera = new THREE.OrthographicCamera(0, 0, 0, 0, -1000, 1000);
            camera.position.z = 2;

            const uniforms = {
                time: { value: 0 },
                resolution: { value: new THREE.Vector4() },
                uTexture: { value: null },
                uDataTexture: { value: null }
            };

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(imageSrc, texture => {
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                uniforms.uTexture.value = texture;
                handleResize();
            });

            const size = grid;
            const data = new Float32Array(4 * size * size);
            for (let i = 0; i < size * size; i++) {
                data[i * 4] = Math.random() * 255 - 125;
                data[i * 4 + 1] = Math.random() * 255 - 125;
            }

            const dataTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
            dataTexture.needsUpdate = true;
            uniforms.uDataTexture.value = dataTexture;

            const material = new THREE.ShaderMaterial({
                side: THREE.DoubleSide,
                uniforms,
                vertexShader,
                fragmentShader,
                transparent: true
            });

            const geometry = new THREE.PlaneGeometry(1, 1, size - 1, size - 1);
            const plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

            const handleResize = () => {
                if (!container || !renderer || !camera) return;

                const rect = container.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                if (width === 0 || height === 0) return;

                const containerAspect = width / height;

                renderer.setSize(width, height);

                if (plane) {
                    plane.scale.set(containerAspect, 1, 1);
                }

                const frustumHeight = 1;
                const frustumWidth = frustumHeight * containerAspect;
                camera.left = -frustumWidth / 2;
                camera.right = frustumWidth / 2;
                camera.top = frustumHeight / 2;
                camera.bottom = -frustumHeight / 2;
                camera.updateProjectionMatrix();

                uniforms.resolution.value.set(width, height, 1, 1);
            };

            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(() => handleResize());
                resizeObserver.observe(container);
            } else {
                window.addEventListener('resize', handleResize);
            }

            const mouseState = {
                x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0
            };

            const handleMouseMove = e => {
                const rect = container.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = 1 - (e.clientY - rect.top) / rect.height;
                mouseState.vX = x - mouseState.prevX;
                mouseState.vY = y - mouseState.prevY;
                Object.assign(mouseState, { x, y, prevX: x, prevY: y });
            };

            const handleMouseLeave = () => {
                if (dataTexture) {
                    dataTexture.needsUpdate = true;
                }
                Object.assign(mouseState, {
                    x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0
                });
            };

            container.addEventListener('mousemove', handleMouseMove);
            container.addEventListener('mouseleave', handleMouseLeave);

            handleResize();

            const animate = () => {
                requestAnimationFrame(animate);

                if (!renderer || !scene || !camera) return;

                uniforms.time.value += 0.05;

                const data = dataTexture.image.data;
                for (let i = 0; i < size * size; i++) {
                    data[i * 4] *= relaxation;
                    data[i * 4 + 1] *= relaxation;
                }

                const gridMouseX = size * mouseState.x;
                const gridMouseY = size * mouseState.y;
                const maxDist = size * mouse;

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const distSq = Math.pow(gridMouseX - i, 2) + Math.pow(gridMouseY - j, 2);
                        if (distSq < maxDist * maxDist) {
                            const index = 4 * (i + size * j);
                            const power = Math.min(maxDist / Math.sqrt(distSq), 10);
                            data[index] += strength * 100 * mouseState.vX * power;
                            data[index + 1] -= strength * 100 * mouseState.vY * power;
                        }
                    }
                }

                dataTexture.needsUpdate = true;
                renderer.render(scene, camera);
            };

            animate();
        };

        window.onload = () => {
            initGridDistortion({
                imageSrc: "https://picsum.photos/1920/1080?grayscale",
                grid: 10,
                mouse: 0.1,
                strength: 0.15,
                relaxation: 0.9,
                containerId: 'grid-distortion-container'
            });
        };
    </script>
</body>
</html>